#!/bin/bash
set -eo pipefail

#
# Update the -advertise address based on the interface that ContainerPilot has
# been told to listen on.
#
preStart() {

    if [ -n "$CONSUL_DATACENTER_NAME" ]; then
        _log "Updating consul datacenter name (specified: '${CONSUL_DATACENTER_NAME}' )"
        sed -i "s/CONSUL_DATACENTER_NAME/${CONSUL_DATACENTER_NAME}/" /etc/consul/consul.hcl
    elif [ -f "/native/usr/sbin/mdata-get" ]; then
        DETECTED_DATACENTER_NAME=$(/native/usr/sbin/mdata-get sdc:datacenter_name)
        # re-export so it can be used later in this script
        export CONSUL_DATACENTER_NAME=$DETECTED_DATACENTER_NAME
        _log "Updating consul datacenter name (detected: '${DETECTED_DATACENTER_NAME}')"
        sed -i "s/CONSUL_DATACENTER_NAME/${DETECTED_DATACENTER_NAME}/" /etc/consul/consul.hcl
    else
        _log "Updating consul datacenter name (default: 'dc1')"
        # re-export so it can be used later in this script
        export CONSUL_DATACENTER_NAME=dc1
        sed -i "s/CONSUL_DATACENTER_NAME/dc1/" /etc/consul/consul.hcl
    fi

    if [ -n "$CONSUL_RETRY_JOIN_WAN" ]; then
        _log "Updating consul retry_join_wan field"
        sed -i '/^retry_join_wan/d' /etc/consul/consul.hcl
        echo "retry_join_wan = [${CONSUL_RETRY_JOIN_WAN}]" >> /etc/consul/consul.hcl

        # translate_wan_addrs allows us to reach remote nodes through their advertise_addr_wan
        sed -i '/^translate_wan_addrs/d' /etc/consul/consul.hcl
        _log "Updating consul translate_wan_addrs field"
        echo "translate_wan_addrs = true" >> /etc/consul/consul.hcl

        # only set bind_addr = 0.0.0.0 if none was specified explicitly with CONSUL_BIND_ADDR
        if [ -n "$CONSUL_BIND_ADDR" ]; then
            updateConfigFromEnvOrDefault 'bind_addr' 'CONSUL_BIND_ADDR' "$CONTAINERPILOT_CONSUL_IP"
        else
            sed -i '/^bind_addr/d' /etc/consul/consul.hcl
            _log "Updating consul field bind_addr to 0.0.0.0 CONSUL_BIND_ADDR was empty and CONSUL_RETRY_JOIN_WAN was not empty"
            echo "bind_addr = \"0.0.0.0\"" >> /etc/consul/consul.hcl
        fi
    else
        # if no WAN addresses were provided, set the bind_addr to the private address
        updateConfigFromEnvOrDefault 'bind_addr' 'CONSUL_BIND_ADDR' "$CONTAINERPILOT_CONSUL_IP"
    fi

    IP_ADDRESS=$(hostname -i)

    # the serf_lan_bind field was recently renamed to serf_wan
    # serf_lan tells nodes their address within the LAN
    updateConfigFromEnvOrDefault 'serf_lan'             'CONSUL_SERF_LAN_BIND'      "$CONTAINERPILOT_CONSUL_IP"

    # the serf_wan_bind field was recently renamed to serf_wan
    # if this field is not set WAN joins will be refused since the bind address will differ
    # from the address used to reach the node
    updateConfigFromEnvOrDefault 'serf_wan'             'CONSUL_SERF_WAN_BIND'      "$IP_ADDRESS"

    # advertise_addr tells nodes their private, routeable address
    updateConfigFromEnvOrDefault 'advertise_addr'       'CONSUL_ADVERTISE_ADDR'     "$CONTAINERPILOT_CONSUL_IP"

    # advertise_addr_wan tells nodes their public address for WAN communication
    updateConfigFromEnvOrDefault 'advertise_addr_wan'   'CONSUL_ADVERTISE_ADDR_WAN' "$IP_ADDRESS"

    # there's no consul env for this
    if [ -n "$CONSUL_ENCRYPT" ]; then
        sed -i '/^encrypt =/d' /etc/consul/consul.hcl
        _log "Updating consul translate_wan_addrs field"
        echo "encrypt = \"$CONSUL_ENCRYPT\"" >> /etc/consul/consul.hcl
    else
        _log "Skipping gossip encryption configuration"
    fi

    # this block looks for the files used for enabling TLS support in CONSUL_TLS_PATH
    # and populates the configs in Consul, but not containerpilot
    if [ -n "$CONSUL_TLS_PATH" ] && [ -z "$CONSUL_CACERT$CONSUL_CLIENT_CERT$CONSUL_CLIENT_KEY"]; then

        # notice we are intentionally not exporting these as envs
        # nor are we using containerpilot -putenv
        local consul_cacert="$CONSUL_TLS_PATH/ca.crt"
        local consul_client_cert="$CONSUL_TLS_PATH/$CONSUL_DATACENTER_NAME.crt"
        local consul_client_key="$CONSUL_TLS_PATH/$CONSUL_DATACENTER_NAME.key"

        until find "$consul_cacert" "$consul_client_cert" "$consul_client_key" &>/dev/null
        do
            sleep 5
            _log "Still waiting for TLS key material at: CONSUL_CACERT=$consul_cacert CONSUL_CLIENT_CERT=$consul_client_cert CONSUL_CLIENT_KEY=$consul_client_key"
        done

        if [ -f "$consul_cacert" ] \
            && [ -f "$consul_client_cert" ] \
            && [ -f "$consul_client_key" ]; then

            echo "TLS files found. Updating consul configs: ca_file, cert_file, key_file, verify_outgoing, verify_incoming"

            # these need to be set in the config since containerpilot looks at the same
            # environment variables. containerpilot will crash if it's booting and these are missing

            sed -i '/^ca_file/d' /etc/consul/consul.hcl
            echo "ca_file = \"$(realpath $consul_cacert)\"" >> /etc/consul/consul.hcl
            # /usr/local/bin/containerpilot -putenv "CONSUL_CACERT=$CONSUL_CACERT"

            sed -i '/^cert_file/d' /etc/consul/consul.hcl
            echo "cert_file = \"$(realpath $consul_client_cert)\"" >> /etc/consul/consul.hcl
            # /usr/local/bin/containerpilot -putenv "CONSUL_CLIENT_CERT=$CONSUL_CLIENT_CERT"

            sed -i '/^key_file/d' /etc/consul/consul.hcl
            echo "key_file = \"$(realpath $consul_client_key)\"" >> /etc/consul/consul.hcl
            # /usr/local/bin/containerpilot -putenv "CONSUL_CLIENT_KEY=$CONSUL_CLIENT_KEY"

            # /usr/local/bin/containerpilot -putenv "CONSUL_HTTP_SSL=true"

            # maybe just listen unencrypted on a private address?

            sed -i '/^verify_outgoing =/d' /etc/consul/consul.hcl
            echo "verify_outgoing = true" >> /etc/consul/consul.hcl

            sed -i '/^verify_incoming =/d' /etc/consul/consul.hcl
            echo "verify_incoming = true" >> /etc/consul/consul.hcl

            sed -i '/^verify_incoming_rpc =/d' /etc/consul/consul.hcl
            echo "verify_incoming_rpc = true" >> /etc/consul/consul.hcl

            sed -i '/^verify_incoming_https =/d' /etc/consul/consul.hcl
            echo "verify_incoming_https = true" >> /etc/consul/consul.hcl

            # docs just before https://www.consul.io/docs/agent/options.html#configuration-key-reference say:

            # Consul will not enable TLS for the HTTP API unless the
            # https port has been assigned a port number > 0.

            sed -i 's/^  HTTP_PORT/  http = 8500/' /etc/consul/consul.hcl
            sed -i 's/^  HTTPS_PORT/  https = 8501/' /etc/consul/consul.hcl

            # if TLS is being configured, we probably want to lock down HTTP to only localhost, or
            # a private address. By default, (the empty string) we will listen on a private address,
            # unless the user has requested otherwise (either with something falsy, or with "localhost"
            #
            # Leaving this unspecified and attempting to visit the web UI at the 8500 address (when
            # encryption is set up correctly) will lead to  `ERR_EMPTY_RESPONSE` or `curl: (52) Empty reply from server`
            case "$CONSUL_TLS_PRIVATE_HTTP" in 
                0 | f | n | false | no)
                    sed -i 's/^  HTTP_ADDR/  http = "{{ GetPublicIP }}"/' /etc/consul/consul.hcl ;;
                1 | t | y | true | yes | '')
                    sed -i 's/^  HTTP_ADDR/  http = "{{ GetPrivateIP }}"/' /etc/consul/consul.hcl ;;
                localhost)
                    sed -i 's/^  HTTP_ADDR/  http = "127.0.0.1"/' /etc/consul/consul.hcl ;;
            esac

            sed -i 's/^  HTTPS_ADDR/  https = "{{ GetPublicIP }}"/' /etc/consul/consul.hcl

            ## we should'nt need to do this if we're not giving the certs to ContainerPilot
            # echo "Attempting to reload"

            # /usr/local/bin/containerpilot -reload
        else
            # TODO: not sure what do to here
            echo "TLS files missing from TLS directory. Exiting!"
            exit 1
        fi
    else
        _log "Skipping RPC server TLS configuration"

        # remove HTTPS placeholder line and set http address to 8500
        sed -i '/^  HTTPS_PORT/d' /etc/consul/consul.hcl
        sed -i 's/^  HTTP_PORT/  http = 8500/' /etc/consul/consul.hcl
    fi
}

preStop() {
    echo " ~~~ preStop ~~~"

    if consul info &>/dev/null; then
        consul leave
    else
        echo "We're still bootstrapping, probably."
    fi
}

postStop() {
    echo " ~~~ postStop ~~~"
}

#
# Check if a member of a raft. If consul info returns an error we'll pipefail
# and exit for a failed health check.
#
# If we have no peers then try to join the raft via the CNS svc record.  Once a
# node is connected to at least one other peer it'll get the rest of the raft
# via the Consul LAN gossip.
#
# If we end up joining ourselves we just retry on the next health check until
# we've got the whole cluster together.
#
health() {
    local consul_args=

    if [ -z "${CONSUL}" ]; then
        echo "CONSUL env was not defined."
        exit 1
    fi

    ## TODO: read either:
    # - CONSUL_TLS_PATH
    # or
    # - CONSUL_CACERT
    # - CONSUL_CLIENT_CERT
    # - CONSUL_CLIENT_KEY
    # to prepare consul_args
    #
    # if [ -n "$CONSUL_TLS_PATH" ]; then
    #     consul_args="$consul_args -ca-file=$CONSUL_CACERT"
    #     consul_args="$consul_args -client-cert=$CONSUL_CLIENT_CERT"
    #     consul_args="$consul_args -client-key=$CONSUL_CLIENT_KEY"
    #
    #     if [[ $CONSUL != "https"* ]]; then
    #         consul_args="$consul_args -http-addr=https://$CONSUL:8500"
    #     fi
    # fi

    local info_output=$(consul info $consul_args)

    if [ -z "$info_output" ]; then
        _log "Healtcheck failed while collecting info."
        exit 1
    fi

    if [ $(echo $info_output | awk '/num_peers/{print$3}') == 0 ]; then
        _log "No peers in raft"
        consul join $consul_args ${CONSUL}
    fi
}

_log() {
    echo "    $(date -u '+%Y-%m-%d %H:%M:%S') containerpilot: $@"
}

#
# Defines $1 in the consul configuration as either an env or a default.
# This basically behaves like ${!name_of_var} and ${var:-default} together
# but separates the  indirect reference from the default so it's more obvious
#
# Check if $2 is the name of a defined environment variable and use ${!2} to
# reference it indirectly.
#
# If it is not defined, use $3 as the value
#
updateConfigFromEnvOrDefault() {
    _log "Updating consul field $1"
    sed -i "/^$1/d" /etc/consul/consul.hcl

    if [ -n "${!2}" ]; then
        echo "$1 = \"${!2}\"" >> /etc/consul/consul.hcl
    else
        echo "$1 = \"$3\"" >> /etc/consul/consul.hcl
    fi
}

# ---------------------------------------------------
# parse arguments

# Get function list
funcs=($(declare -F -p | cut -d " " -f 3))

until
    if [ ! -z "$1" ]; then
        # check if the first arg is a function in this file, or use a default
        if [[ " ${funcs[@]} " =~ " $1 " ]]; then
            cmd=$1
            shift 1
        fi

        $cmd "$@"
        if [ $? == 127 ]; then
            help
        fi

        exit
    else
        health
    fi
do
    echo
done
